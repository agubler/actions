{"version":3,"file":"compose.js","sourceRoot":"","sources":["compose.ts"],"names":["rebase","copyProperties","stamp","cloneFactory","cloneFactory.factory","extend","mixin","overlay","from","doFrom","before","doBefore","after","doAfter","around","doAround","aspect","aspect.mapAdvice","create"],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\nimport {\n\tbefore as aspectBefore,\n\tafter as aspectAfter,\n\taround as aspectAround,\n\tBeforeAdvice,\n\tAfterAdvice,\n\tAroundAdvice\n} from './aspect';\n\n/* A weakmap that will store initialization functions for compose constructors */\nconst initFnMap = new WeakMap<Function, ComposeInitializationFunction<any>[]>();\n\n/**\n * A helper funtion to return a function that is rebased\n * @param  {Function} fn The function to be rebased\n * @return {Function}    The rebased function\n */\nfunction rebase(fn: Function): Function {\n   return function(...args: any[]) {\n\t   return fn.apply(this, [ this ].concat(args));\n   };\n}\n\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n */\nfunction copyProperties(target: {}, ...sources: {}[]) {\n  sources.forEach(source => {\n    Object.defineProperties(\n\t\ttarget,\n\t\tObject.getOwnPropertyNames(source).reduce(\n\t\t\t(descriptors: { [ index: string ]: any }, key: string) => {\n\t\t\t\tdescriptors[ key ] = Object.getOwnPropertyDescriptor(source, key);\n\t\t\t\treturn descriptors;\n\t\t\t},\n\t\t\t{}\n\t\t)\n\t);\n  });\n  return target;\n}\n\n/* The rebased functions we need to decorate compose constructors with */\nconst doExtend = rebase(extend);\nconst doMixin = rebase(mixin);\nconst doOverlay = rebase(overlay);\nconst doAspect = rebase(aspect);\n\n/**\n * A convenience function to decorate compose class constructors\n * @param {any} base The target constructor\n */\nfunction stamp(base: any): void {\n   base.extend = doExtend;\n   base.mixin = doMixin;\n   base.overlay = doOverlay;\n   base.from = doFrom;\n   base.before = doBefore;\n   base.after = doAfter;\n   base.around = doAround;\n   base.aspect = doAspect;\n}\n\n/**\n * Take a compose constructor and clone it\n * @param  {ComposeFactory<O, T>} base The base to clone\n * @return {ComposeFactory<O, T>}      The cloned constructor function\n */\nfunction cloneFactory<O, T>(base?: ComposeFactory<O, T>): ComposeFactory<O, T>;\nfunction cloneFactory(base?: any): any {\n\tfunction factory(...args: any[]): any {\n\t\tif (this && this.constructor === factory) {\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\n\t\t}\n\t\tconst instance = Object.create(factory.prototype);\n\t\tinitFnMap.get(factory).forEach(fn => fn.apply(instance, args));\n\t\treturn instance;\n\t}\n\n\tif (base) {\n\t\tcopyProperties(factory.prototype, base.prototype);\n\t\tinitFnMap.set(factory, [].concat(initFnMap.get(base)));\n\t}\n\telse {\n\t\tinitFnMap.set(factory, []);\n\t}\n\tfactory.prototype.constructor = factory;\n\tstamp(factory);\n\tObject.freeze(factory);\n\n\treturn factory;\n}\n\n/* General Interfaces */\n\nexport interface GenericClass<T> {\n\tnew (...args: any[]): T;\n\tprototype: T;\n}\n\nexport interface ComposeInitializationFunction<O> {\n\t(options?: O): void;\n}\n\n/* Extension API */\nexport interface ComposeFactory<O, T> {\n\textend<U>(extension: U): ComposeFactory<O, T & U>;\n}\n\nexport interface Compose {\n\textend<O, A, B>(base: ComposeFactory<O, A>, extension: B): ComposeFactory<O, A & B>;\n}\n\nfunction extend<O, A, B>(base: ComposeFactory<O, A>, extension: B): ComposeFactory<O, A & B>;\nfunction extend<O>(base: ComposeFactory<O, any>, extension: any): ComposeFactory<O, any> {\n\tbase = cloneFactory(base);\n\tcopyProperties(base.prototype, extension);\n\treturn base;\n}\n\n/* Mixin API */\nexport interface ComposeFactory<O, T> {\n\tmixin<P, U>(mixin: GenericClass<U>): ComposeFactory<O, T & U>;\n\tmixin<P, U>(mixin: ComposeFactory<P, U>): ComposeFactory<O & P, T & U>;\n}\n\nexport interface Compose {\n\tmixin<O, A, B>(base: ComposeFactory<O, A>, mixin: GenericClass<B>): ComposeFactory<O, A & B>;\n\tmixin<O, P, A, B>(base: ComposeFactory<O, A>, mixin: ComposeFactory<P, B>): ComposeFactory<O & P, A & B>;\n}\n\nfunction mixin<O, A, B>(base: ComposeFactory<O, A>, mixin: GenericClass<B>): ComposeFactory<O, A & B>;\nfunction mixin<O, P, A, B>(base: ComposeFactory<O, A>, mixin: ComposeFactory<P, B>): ComposeFactory<O & P, A & B>;\nfunction mixin<O>(base: ComposeFactory<O, any>, mixin: any): ComposeFactory<O, any> {\n\tbase = cloneFactory(base);\n\tcopyProperties(base.prototype, mixin.prototype);\n\treturn base;\n}\n\n/* Overlay API */\nexport interface OverlayFunction<T> {\n\t(proto: T): void;\n}\n\nexport interface ComposeFactory<O, T> {\n\t overlay(overlayFunction: OverlayFunction<T>): ComposeFactory<O, T>;\n}\n\nexport interface Compose {\n\toverlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A>;\n}\n\nfunction overlay<O, A>(base: ComposeFactory<O, A>, overlayFunction: OverlayFunction<A>): ComposeFactory<O, A> {\n\tbase = cloneFactory(base);\n\toverlayFunction(base.prototype);\n\treturn base;\n}\n\n/* AOP/Inheritance API */\n\nexport interface AspectAdvice {\n\tbefore?: { [method: string]: BeforeAdvice };\n\tafter?: { [method: string]: AfterAdvice<any> };\n\taround?: { [method: string]: AroundAdvice<any> };\n}\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\nexport interface ComposeFactory<O, T> {\n\tfrom(base: GenericClass<any>, method: string): ComposeFactory<O, T>;\n\tfrom(base: ComposeFactory<any, any>, method: string): ComposeFactory<O, T>;\n\n\tbefore(method: string, advice: BeforeAdvice): ComposeFactory<O, T>;\n\tafter<P>(method: string, advice: AfterAdvice<P>): ComposeFactory<O, T>;\n\taround<P>(method: string, advice: AroundAdvice<P>): ComposeFactory<O, T>;\n\n\taspect(advice: AspectAdvice): ComposeFactory<O, T>;\n}\n\nexport interface Compose {\n\tfrom<T extends Function>(base: GenericClass<any>, method: string): T;\n\tfrom<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\n\n\tbefore<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\n\n\tafter<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\n\n\taround<T>(base: GenericClass<any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(base: ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\n\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\n}\n\nfunction from<T extends Function>(base: GenericClass<any>, method: string): T;\nfunction from<T extends Function>(base: ComposeFactory<any, any>, method: string): T;\nfunction from<T extends Function>(base: any, method: string): T {\n\treturn base.prototype[method];\n}\n\nfunction doFrom<O, T>(base: GenericClass<any>, method: string): ComposeFactory<O, T>;\nfunction doFrom<O, T>(base: ComposeFactory<any, any>, method: string): ComposeFactory<O, T>;\nfunction doFrom(base: any, method: string): ComposeFactory<any, any> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = base.prototype[method];\n\treturn clone;\n}\n\nfunction before<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(base: ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\nfunction before(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: BeforeAdvice;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\n}\n\nfunction doBefore<O, T>(method: string, advice: BeforeAdvice): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectBefore((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory<O, T>> clone;\n}\n\nfunction after<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\n}\n\nfunction doAfter<O, P, T>(method: string, advice: AfterAdvice<P>): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAfter((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <O, T>> clone;\n}\n\nfunction around<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(base: ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\nfunction around(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAround(<GenericFunction<any>> method, advice);\n}\n\nfunction doAround<O, P, T>(method: string, advice: AroundAdvice<P>): ComposeFactory<O, T> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAround((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <O, T>> clone;\n}\n\nfunction aspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A> {\n\tconst clone = cloneFactory(base);\n\n\tfunction mapAdvice(adviceHash: { [method: string ]: Function }, advisor: Function): void {\n\t\tfor (let key in adviceHash) {\n\t\t\tif (key in clone.prototype) {\n\t\t\t\t(<any> clone.prototype)[key] = advisor((<any> clone.prototype)[key], adviceHash[key]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('Trying to advise non-existing method: \"' + key + '\"');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (advice.before) {\n\t\tmapAdvice(advice.before, before);\n\t}\n\tif (advice.after) {\n\t\tmapAdvice(advice.after, after);\n\t}\n\tif (advice.around) {\n\t\tmapAdvice(advice.around, around);\n\t}\n\treturn clone;\n}\n\n/* Creation API */\nexport interface ComposeFactory<O, T> {\n\t(options?: O): T;\n\tprototype: T;\n}\n\nexport interface Compose {\n\t<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\n\t<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\n\t<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\n\tcreate<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\n\tcreate<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\n\tcreate<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\n}\n\nfunction create<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\nfunction create<O, A, P>(base: ComposeFactory<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeFactory<O & P, A>;\nfunction create<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeFactory<O, A>;\nfunction create<O>(base: any, initFunction?: ComposeInitializationFunction<O>): any {\n\tconst factory = cloneFactory();\n\tif (initFunction) {\n\t\tinitFnMap.get(factory).push(initFunction);\n\t}\n\n\t/* mixin the base into the prototype */\n\tcopyProperties(factory.prototype, typeof base === 'function' ? base.prototype : base);\n\n   /* return the new constructor */\n   return factory;\n}\n\n/* Generate compose */\n(<Compose> create).create = create;\n(<Compose> create).extend = extend;\n(<Compose> create).mixin = mixin;\n(<Compose> create).overlay = overlay;\n(<Compose> create).from = from;\n(<Compose> create).before = before;\n(<Compose> create).after = after;\n(<Compose> create).around = around;\n(<Compose> create).aspect = aspect;\n\nconst compose: Compose = <Compose> create;\n\nexport default compose;\n"]}