{"version":3,"file":"createStateful.js","sourceRoot":"","sources":["createStateful.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventObject, Handle } from 'dojo-core/interfaces';\nimport { deepAssign } from 'dojo-core/lang';\nimport Promise from 'dojo-core/Promise';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { Observable, Subscription } from 'rxjs/Rx';\nimport createEvented, { Evented, EventedOptions, EventedListener } from './createEvented';\nimport compose, { ComposeFactory } from '../compose';\n\n/**\n * Base State interface\n */\nexport interface State {\n\t[prop: string]: any;\n}\n\nexport interface ObservableState<S extends State> {\n\t/**\n\t * A method that allows the return of an `Observable` interface for a particular `id`\n\t * @param id The ID to observe\n\t */\n\tobserve(id: string): Observable<S>;\n\n\t/**\n\t * A method that allows the `Stateful` to provide a change to its state, instead of\n\t * changing its state directly.\n\t * @param partial The partial state to be *patched*\n\t * @param options A map of options, which includes the `id` being observed\n\t */\n\tpatch(partial: any, options?: { id?: string }): Promise<S>;\n}\n\nexport interface StatefulOptions<S extends State> extends EventedOptions {\n\t/**\n\t * State that should be set during creation\n\t */\n\tstate?: S;\n\n\t/**\n\t * An ID to be used in conjunction with the `stateFrom` option to observe the state\n\t */\n\tid?: string;\n\n\t/**\n\t * An object that the Stateful should observe its state from, which supplies an `observe` and\n\t * `patch` methods to be able to manage its state\n\t */\n\tstateFrom?: ObservableState<S>;\n}\n\nexport interface StateChangeEvent<S extends State> extends EventObject {\n\t/**\n\t * The event type\n\t */\n\ttype: string;\n\n\t/**\n\t * The state of the target\n\t */\n\tstate: S;\n\n\t/**\n\t * A Stateful instance\n\t */\n\ttarget: Stateful<S>;\n}\n\nexport interface Stateful<S extends State> extends Evented {\n\t/**\n\t * A read only view of the state\n\t */\n\tstate: S;\n\n\t/**\n\t * Set the state on the instance.\n\t *\n\t * Set state can take a partial value, therefore if a key is ommitted from the value, it will not be changed.\n\t * To *clear* a value, set a key to `undefined`\n\t *\n\t * @param value The state (potentially partial) to be set\n\t */\n\tsetState(value: S): void;\n\n\t/**\n\t * Observe (and update) the state from an Observable\n\t * @param id The ID to be observed on the Observable\n\t * @param observable An object which provides a `observe` and `patch` methods which allow `Stateful` to be able to\n\t *                   manage its state.\n\t */\n\tobserveState(id: string, observable: ObservableState<S>): Handle;\n\n\t/**\n\t * Add a listener for an event\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;\n\ton(type: string, listener: EventedListener<EventObject>): Handle;\n}\n\nexport interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {\n\t<S extends State>(options?: StatefulOptions<S>): Stateful<S>;\n}\n\n/**\n * Internal interface which contains references to an observed state\n */\ninterface ObservedState {\n\tid: string;\n\tobservable: ObservableState<State>;\n\tsubscription: Subscription;\n\thandle: Handle;\n}\n\n/**\n * A weak map of stateful instances to their obseved state references\n */\nconst observedStateMap = new WeakMap<Stateful<State>, ObservedState>();\n\n/**\n * Internal function to unobserve the state of a `Stateful`\n * @param stateful The `Stateful` object to unobserve\n */\nfunction unobserve(stateful: Stateful<State>): void {\n\tconst observedState = observedStateMap.get(stateful);\n\tif (observedState) {\n\t\tobservedState.handle.destroy();\n\t\tstateful.emit({\n\t\t\ttype: 'observe:complete',\n\t\t\ttarget: stateful\n\t\t});\n\t}\n}\n\n/**\n * Internal function that actually applies the state to the Stateful's state and\n * emits the `statechange` event.\n * @param stateful The Stateful instance\n * @param state The State to be set\n */\nfunction setStatefulState(stateful: Stateful<State>, state: State): void {\n\tstate = deepAssign(stateWeakMap.get(stateful), state);\n\tstateful.emit({\n\t\ttype: 'statechange',\n\t\tstate,\n\t\ttarget: stateful\n\t});\n}\n\n/**\n * A weak map that contains the stateful's state\n */\nconst stateWeakMap = new WeakMap<Stateful<State>, State>();\n\n/**\n * Create an instance of a stateful object\n */\nconst createStateful: StatefulFactory = compose({\n\t\tget state(): any {\n\t\t\treturn stateWeakMap.get(this);\n\t\t},\n\n\t\tsetState(value: State): void {\n\t\t\tconst stateful: Stateful<State> = this;\n\t\t\tconst observedState = observedStateMap.get(stateful);\n\t\t\tif (observedState) {\n\t\t\t\tobservedState.observable.patch(value, { id: observedState.id });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetStatefulState(stateful, value);\n\t\t\t}\n\t\t},\n\n\t\tobserveState(id: string, observable: ObservableState<State>): Handle {\n\t\t\tconst stateful: Stateful<State> = this;\n\t\t\tlet observedState = observedStateMap.get(stateful);\n\t\t\tif (observedState) {\n\t\t\t\tif (observedState.id === id && observedState.observable === observable) {\n\t\t\t\t\treturn observedState.handle;\n\t\t\t\t}\n\t\t\t\tthrow new Error(`Already observing state with ID '${observedState.id}'`);\n\t\t\t}\n\t\t\tobservedState = {\n\t\t\t\tid,\n\t\t\t\tobservable,\n\t\t\t\tsubscription: observable\n\t\t\t\t\t.observe(id)\n\t\t\t\t\t.subscribe(\n\t\t\t\t\t\t(item) => setStatefulState(stateful, item), /* next handler */\n\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\t/* TODO: Should we emit an error, instead of throwing? */\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}, /* error handler */\n\t\t\t\t\t\t() => unobserve(stateful)), /* completed handler */\n\t\t\t\thandle: {\n\t\t\t\t\tdestroy() {\n\t\t\t\t\t\tconst observedState = observedStateMap.get(stateful);\n\t\t\t\t\t\tif (observedState) {\n\t\t\t\t\t\t\tobservedState.subscription.unsubscribe();\n\t\t\t\t\t\t\tobservedStateMap.delete(stateful);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservedStateMap.set(stateful, observedState);\n\t\t\treturn observedState.handle;\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createEvented,\n\t\tinitialize(instance: Stateful<State>, options: StatefulOptions<State>) {\n\t\t\tconst state = {};\n\t\t\tstateWeakMap.set(instance, state);\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tstateWeakMap.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\tif (options.state) {\n\t\t\t\t\tinstance.setState(options.state);\n\t\t\t\t}\n\t\t\t\tif (options.id && options.stateFrom) {\n\t\t\t\t\tinstance.own(instance.observeState(options.id, options.stateFrom));\n\t\t\t\t}\n\t\t\t\telse if (options.id || options.stateFrom) {\n\t\t\t\t\tthrow new TypeError('Factory requires options \"id\" and \"stateFrom\" to be supplied together.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createStateful;\n"]}