{"version":3,"file":"createDestroyable.js","sourceRoot":"","sources":["createDestroyable.ts"],"names":[],"mappings":";;;;;;;;;IACA,wBAAoB,mBAAmB,CAAC,CAAA;IACxC,wBAAoB,mBAAmB,CAAC,CAAA;IACxC,wBAAwC,YAAY,CAAC,CAAA;IAkBrD;;OAEG;IACH,IAAM,IAAI,GAAG;QACZ,MAAM,CAAC,iBAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC,CAAC;IAEF;;;OAGG;IACH,IAAM,SAAS,GAAG;QACjB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IAClD,CAAC,CAAC;IAEF;;OAEG;IACH,IAAM,cAAc,GAAG,IAAI,iBAAO,EAAyB,CAAC;IAE5D;;;OAGG;IACH,uBAA8B,KAAU;QACvC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,UAAU,CAAC,CAAC;IACpF,CAAC;IAFe,qBAAa,gBAE5B,CAAA;IAED;;;OAGG;IACH,IAAM,iBAAiB,GAAqC,iBAAO,CAAC;QACnE,GAAG,YAAC,MAAc;YACjB,IAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACzC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrB,MAAM,CAAC;gBACN,OAAO;oBACN,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;oBACxC,MAAM,CAAC,OAAO,EAAE,CAAC;gBAClB,CAAC;aACD,CAAC;QACH,CAAC;QACD,OAAO;YAAP,iBAWC;YAVA,MAAM,CAAC,IAAI,iBAAO,CAAC,UAAC,OAAO;gBAC1B,IAAM,WAAW,GAAgB,KAAI,CAAC;gBACtC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,UAAC,MAAM;oBAC9C,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;gBAC9C,CAAC,CAAC,CAAC;gBACH,cAAc,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;gBACnC,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC3B,WAAW,CAAC,GAAG,GAAG,SAAS,CAAC;gBAC5B,OAAO,CAAC,IAAI,CAAC,CAAC;YACf,CAAC,CAAC,CAAC;QACJ,CAAC;KACD,EAAE,UAAC,QAAQ;QACX,cAAc,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;IAEH;sBAAe,iBAAiB,CAAC","sourcesContent":["import { Handle } from 'dojo-core/interfaces';\nimport Promise from 'dojo-core/Promise';\nimport WeakMap from 'dojo-core/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\n\nexport interface Destroyable {\n\t/**\n\t * Take a handle and *own* it, which ensures that the handle's\n\t * `destroy()` method is called when the *owner* is destroyed.\n\t * @param handle The handle to own\n\t * @returns A handle to *unown* the passed handle\n\t */\n\town(handle: Handle): Handle;\n\n\t/**\n\t * Invoke `destroy()` on any owned handles.\n\t * @returns A promise that resolves to `true` if successful, otherwise `false`\n\t */\n\tdestroy(): Promise<boolean>;\n}\n\n/**\n * A reference to a function that always returns a promise which resolves to false\n */\nconst noop = function(): Promise<boolean> {\n\treturn Promise.resolve(false);\n};\n\n/**\n * A reference to a function that throws, used to replace the `own()` method after\n * destruction\n */\nconst destroyed = function(): Handle {\n\tthrow new Error('Call made to destroyed method');\n};\n\n/**\n * A weak map for *owning* handles on instances\n */\nconst handlesWeakMap = new WeakMap<Destroyable, Handle[]>();\n\n/**\n * A type guard that determines if the value is a Destroyable\n * @param value The value to guard for\n */\nexport function isDestroyable(value: any): value is Destroyable {\n\treturn Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n}\n\n/**\n * A mixin which adds the concepts of being able to *destroy* handles which the instance\n * *owns*\n */\nconst createDestroyable: ComposeFactory<Destroyable, any> = compose({\n\town(handle: Handle): Handle {\n\t\tconst handles = handlesWeakMap.get(this);\n\t\thandles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\thandles.splice(handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\tdestroy() {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst destroyable: Destroyable = this;\n\t\t\thandlesWeakMap.get(destroyable).forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\thandlesWeakMap.delete(destroyable);\n\t\t\tdestroyable.destroy = noop;\n\t\t\tdestroyable.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}, (instance) => {\n\thandlesWeakMap.set(instance, []);\n});\n\nexport default createDestroyable;\n"]}