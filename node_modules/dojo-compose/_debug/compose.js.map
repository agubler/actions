{"version":3,"file":"compose.js","sourceRoot":"","sources":["compose.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\nimport {\n\tbefore as aspectBefore,\n\tafter as aspectAfter,\n\taround as aspectAround,\n\tBeforeAdvice,\n\tAfterAdvice,\n\tAroundAdvice\n} from './aspect';\n\n/**\n * A weakmap that will store initialization functions for compose constructors\n */\nconst initFnMap = new WeakMap<Function, ComposeInitializationFunction<any, any>[]>();\n\n/**\n * A weakmap that will store static properties for compose factories\n */\nconst staticPropertyMap = new WeakMap<Function, {}>();\n\n/**\n * A helper funtion to return a function that is rebased to infer that the\n * first argument of the passed function will be the `this` when the function\n * is executed.\n *\n * @param  fn The function to be rebased\n * @return    The rebased function\n */\nfunction rebase(fn: (base: any, ...args: any[]) => any): (...args: any[]) => any {\n\treturn function(...args: any[]) {\n\t\treturn fn.apply(this, [ this ].concat(args));\n\t};\n}\n\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n */\nfunction copyProperties(target: {}, ...sources: {}[]) {\n\tsources.forEach(source => {\n\t\tObject.defineProperties(\n\t\t\ttarget,\n\t\t\tObject.getOwnPropertyNames(source).reduce(\n\t\t\t\t(descriptors: { [ index: string ]: any }, key: string) => {\n\t\t\t\t\tdescriptors[ key ] = Object.getOwnPropertyDescriptor(source, key);\n\t\t\t\t\treturn descriptors;\n\t\t\t\t},\n\t\t\t\t{}\n\t\t\t)\n\t\t);\n\t});\n\treturn target;\n}\n\n/* The rebased functions we need to decorate compose constructors with */\n\n/**\n * Perform an extension of a class\n */\nconst doExtend = rebase(extend);\n\n/**\n * Perform a mixin of a class\n */\nconst doMixin = rebase(mixin);\n\n/**\n * Perform an overlay of a class\n */\nconst doOverlay = rebase(overlay);\n\n/**\n * Apply aspect advice to a class\n */\nconst doAspect = rebase(aspect);\n\n/**\n * Add static method/properties to a class\n */\nconst doStatic = rebase(_static);\n\n/**\n * Take a mixin and return a factory descriptor for the mixin\n *\n * @param mixin The factory to return the descriptor for\n * @template T The outer type of the descriptor\n * @template O The outer factory options of the descriptor\n * @template U The inner type of the descriptor\n * @template P The inner factory options of the descriptor\n */\nfunction factoryDescriptor<T, O, U, P>(mixin: ComposeFactory<U, P>): ComposeMixinDescriptor<T, O, U, P> {\n\treturn {\n\t\tmixin: mixin\n\t};\n};\n\n/**\n * Generate a factory descriptor for a class\n */\nconst doFactoryDescriptor = rebase(factoryDescriptor);\n\n/**\n * A convenience function to decorate compose class constructors\n * @param base The target constructor\n */\nfunction stamp(base: any): void {\n\tbase.extend = doExtend;\n\tbase.mixin = doMixin;\n\tbase.overlay = doOverlay;\n\tbase.from = doFrom;\n\tbase.before = doBefore;\n\tbase.after = doAfter;\n\tbase.around = doAround;\n\tbase.aspect = doAspect;\n\tbase.factoryDescriptor = doFactoryDescriptor;\n\tbase.static = doStatic;\n}\n\n/**\n * Take a compose factory and clone it\n *\n * @param  base             The base to clone\n * @param  staticProperties Any static properties for the factory\n * @return                  The cloned constructor function\n */\nfunction cloneFactory<T, O, S>(base: ComposeFactory<T, O>, staticProperties: S): ComposeFactory<T, O> & S;\nfunction cloneFactory<T, O>(base: ComposeFactory<T, O>): ComposeFactory<T, O>;\nfunction cloneFactory<T, O>(): ComposeFactory<T, O>;\nfunction cloneFactory(base?: any, staticProperties?: any): any {\n\n\tfunction factory(...args: any[]): any {\n\t\tif (this && this.constructor === factory) {\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\n\t\t}\n\t\tconst instance = Object.create(factory.prototype);\n\t\targs.unshift(instance);\n\t\tinitFnMap.get(factory).forEach(fn => fn.apply(null, args));\n\t\treturn instance;\n\t}\n\n\tif (base) {\n\t\tcopyProperties(factory.prototype, base.prototype);\n\t\tinitFnMap.set(factory, [].concat(initFnMap.get(base)));\n\t}\n\telse {\n\t\tinitFnMap.set(factory, []);\n\t}\n\tfactory.prototype.constructor = factory;\n\tstamp(factory);\n\tif (staticProperties) {\n\t\tif (isComposeFactory(staticProperties)) {\n\t\t\tstaticProperties = staticPropertyMap.get(staticProperties) || {};\n\t\t}\n\t\tstaticPropertyMap.set(factory, staticProperties);\n\t\tcopyProperties(factory, staticProperties);\n\t}\n\tObject.freeze(factory);\n\n\treturn factory;\n}\n\n/**\n * Takes any init functions from source and concats them to base\n * @param target The compose factory to copy the init functions onto\n * @param source The ComposeFactory to copy the init functions from\n */\nfunction concatInitFn<T, O, U, P>(target: ComposeFactory<T, O>, source: ComposeFactory<U, P>): void {\n\tconst sourceInitFns = initFnMap.get(source);\n\n\t/* making sure only unique functions get added */\n\tconst targetInitFns = initFnMap.get(target).filter((fn) => {\n\t\treturn sourceInitFns.indexOf(fn) < 0;\n\t});\n\n\t/* now prepend the source init functions to the unique init functions for the target */\n\tinitFnMap.set(target, sourceInitFns.concat(targetInitFns));\n}\n\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nexport function isComposeFactory(value: any): value is ComposeFactory<any, any> {\n\treturn Boolean(initFnMap.get(value));\n}\n\n/* General Interfaces */\n\n/**\n * Used to adapt any consructor functions or classes to a compose factory\n */\nexport interface GenericClass<T> {\n\tnew (...args: any[]): T;\n\tprototype: T;\n}\n\nexport interface ComposeInitializationFunction<T, O> {\n\t/**\n\t * A callback function use to initialize a new created instance\n\t * @param instance The newly constructed instance\n\t * @param options Any options that were passed to the factory\n\t * @template T The type of the instance\n\t * @template O The type of the options being passed\n\t */\n\t(instance: T, options?: O): void;\n}\n\n/* Extension API */\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extend the factory prototype with the supplied object literal, class, or factory\n\t * @param extension The object literal, class or factory to extend\n\t * @template T The original type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<U>(extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<U, P>(extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Extend a compose factory prototype with the supplied object literal, class, or\n\t * factory.\n\t * @param base The base compose factory to extend\n\t * @param extension The object literal, class or factory that is the extension\n\t * @template T The base type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the base factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<T, O, U>(base: ComposeFactory<T, O>, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\nfunction extend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\nfunction extend<O>(base: ComposeFactory<any, O>, extension: any): ComposeFactory<any, O> {\n\tbase = cloneFactory(base);\n\tcopyProperties(base.prototype, typeof extension === 'function' ? extension.prototype : extension);\n\treturn base;\n}\n\n/* Overlay API */\nexport interface OverlayFunction<T> {\n\t/**\n\t * A function that takes a factories prototype, allowing it to change the prototype without\n\t * mutating the type structure.\n\t *\n\t * @param proto The object literal that should be overlayed on the factories prototype.\n\t * @template T The type of the factories prototype\n\t */\n\t(proto: T): void;\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Provide a function that mutates the factories prototype but does not change the factory's class\n\t * structure.\n\t *\n\t * @param overlayFunction The function which receives the factory's prototype\n\t * @template T The type of the factory's prototype\n\t */\n\toverlay(overlayFunction: OverlayFunction<T>): this;\n}\n\nexport interface Compose {\n\t/**\n\t * A static method that takes a compose factory and applies an overlay function to the factory,\n\t * returning a new compose factory with a mutated prototype.\n\t *\n\t * @param base The base ComposeFactory\n\t * @param overlayFunction The function which receives the base factory's prototype\n\t * @template T The type of the factory's prototype\n\t * @template O The options for the factory's creation\n\t */\n\toverlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;\n}\n\nfunction overlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O> {\n\tbase = cloneFactory(base);\n\toverlayFunction(base.prototype);\n\treturn base;\n}\n\n/* AOP/Inheritance API */\n\nexport interface AspectAdvice {\n\t/**\n\t * Any methods where the supplied advice should be applied *before* the base method is invoked\n\t */\n\tbefore?: { [method: string]: BeforeAdvice };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *after* the base method is invoked\n\t */\n\tafter?: { [method: string]: AfterAdvice<any> };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *around* the base method\n\t */\n\taround?: { [method: string]: AroundAdvice<any> };\n}\n\n/* Mixin API */\n\n/**\n * Either a class, object literal, or a factory\n */\nexport type ComposeMixinItem<T, O> = GenericClass<T> | T | ComposeFactory<T, O>;\n\nexport interface ComposeMixinDescriptor<T, O, U, P> {\n\t/**\n\t * The class, object literal, or factory to be mixed in\n\t */\n\tmixin?: ComposeMixinItem<U, P>;\n\n\t/**\n\t * An initialize function to be executed upon construction\n\t */\n\tinitialize?: ComposeInitializationFunction<T & U, O & P>;\n\n\t/**\n\t * Aspect Oriented Advice to be mixed into the factory\n\t */\n\taspectAdvice?: AspectAdvice;\n}\n\n/**\n * Identifies a compose factory or other object that can be\n * transformed into a ComposeMixinDescriptor\n */\nexport interface ComposeMixinable<U, P> {\n\t/**\n\t * A method that offers up a ComposeMixinDescriptor to allow complex mixin in of factories\n\t */\n\tfactoryDescriptor<T, O>(): ComposeMixinDescriptor<T, O, U, P>;\n}\n\n// export type descriptorFactory\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into the factory\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<U, P>(mixin: ComposeMixinable<U, P>):\n\t\tComposeFactory<T & U, O & P>;\n\tmixin<U, P>(mixin: ComposeMixinDescriptor<T, O, U, P>):\n\t\tComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into a factory\n\t * @param base The base factory that is the target of the mixin\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinable<U, P>\n\t): ComposeFactory<T & U, O & P>;\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinDescriptor<T, O, U, P>\n\t): ComposeFactory<T & U, O & P>;\n}\n\nfunction isComposeMixinable(value: any): value is ComposeMixinable<any, any> {\n\treturn Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n}\n\nfunction mixin<T, O, U, P>(\n\tbase: ComposeFactory<T, O>,\n\ttoMixin: ComposeMixinable<U, P> | ComposeMixinDescriptor<T, O, U, P>\n): ComposeFactory<T & U, O & P> {\n\tbase = cloneFactory(base);\n\tconst baseInitFns = initFnMap.get(base);\n\tconst mixin = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\tconst mixinType =  mixin.mixin;\n\tif (mixinType) {\n\t\tlet mixinFactory = isComposeFactory(mixinType) ? mixinType : create(mixinType);\n\t\tif (mixin.initialize) {\n\t\t\tif (baseInitFns.indexOf(mixin.initialize) < 0) {\n\t\t\t\tbaseInitFns.unshift(mixin.initialize);\n\t\t\t}\n\t\t}\n\t\tconcatInitFn(base, mixinFactory);\n\t\tcopyProperties(base.prototype, mixinFactory.prototype);\n\t}\n\telse if (mixin.initialize) {\n\t\tif (baseInitFns.indexOf(mixin.initialize) < 0) {\n\t\t\tbaseInitFns.unshift(mixin.initialize);\n\t\t}\n\t}\n\tif (mixin.aspectAdvice) {\n\t\tbase = aspect(base, mixin.aspectAdvice);\n\t}\n\treturn base as ComposeFactory<T & U, O & P>;\n}\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extract a method from another Class or Factory and add it to the returned factory\n\t * @param base The base Class or Factory\n\t * @param method The name of the method to extract\n\t */\n\tfrom(base: GenericClass<any> | ComposeFactory<any, any>, method: string): this;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tbefore(method: string, advice: BeforeAdvice): this;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tafter<P>(method: string, advice: AfterAdvice<P>): this;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\taround<P>(method: string, advice: AroundAdvice<P>): this;\n\n\t/**\n\t * Provide an object literal which can contain a map of advice to apply\n\t * @param advice An object literal which contains the maps of advice to apply\n\t */\n\taspect(advice: AspectAdvice): this;\n}\n\nexport interface Compose {\n\t/**\n\t * Extract a method from another Class or Factory and return it\n\t * @param base The Class or Factory to extract from\n\t * @param method The method name to be extracted\n\t */\n\tfrom<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string): T;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tbefore<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tafter<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\taround<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice to methods that exist in the base factory using the supplied advice map\n\t * @param base The Factory that contains the methods the advice will be applied to\n\t * @param advice The map of advice to be applied\n\t */\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\n}\n\nfunction from<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string): T {\n\treturn base.prototype[method];\n}\n\nfunction doFrom<T, O>(base: GenericClass<any> | ComposeFactory<any, any>, method: string): ComposeFactory<T, O> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = base.prototype[method];\n\treturn clone as ComposeFactory<T, O>;\n}\n\nfunction before<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\nfunction before(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: BeforeAdvice;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\n}\n\nfunction doBefore<T, O>(method: string, advice: BeforeAdvice): ComposeFactory<T, O> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectBefore((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory<T, O>> clone;\n}\n\nfunction after<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\n}\n\nfunction doAfter<T, P, O>(method: string, advice: AfterAdvice<P>): ComposeFactory<T, O> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAfter((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <T, O>> clone;\n}\n\nfunction around<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\nfunction around(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAround(<GenericFunction<any>> method, advice);\n}\n\nfunction doAround<T, P, O>(method: string, advice: AroundAdvice<P>): ComposeFactory<T, O> {\n\tconst clone = cloneFactory(this);\n\t(<any> clone.prototype)[method] = aspectAround((<any> clone.prototype)[method], advice);\n\treturn <ComposeFactory <T, O>> clone;\n}\n\nfunction aspect<T, O>(base: ComposeFactory<T, O>, advice: AspectAdvice): ComposeFactory<T, O> {\n\tconst clone = cloneFactory(base);\n\n\tfunction mapAdvice(adviceHash: { [method: string ]: Function }, advisor: Function): void {\n\t\tfor (let key in adviceHash) {\n\t\t\tif (key in clone.prototype) {\n\t\t\t\t(<any> clone.prototype)[key] = advisor((<any> clone.prototype)[key], adviceHash[key]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('Trying to advise non-existing method: \"' + key + '\"');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (advice.before) {\n\t\tmapAdvice(advice.before, before);\n\t}\n\tif (advice.after) {\n\t\tmapAdvice(advice.after, after);\n\t}\n\tif (advice.around) {\n\t\tmapAdvice(advice.around, around);\n\t}\n\treturn clone;\n}\n\n/* Creation API */\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Create a new instance\n\t * @param options Options that are passed to the initialization functions of the factory\n\t */\n\t(options?: O): T;\n\n\t/**\n\t * The read only prototype of the factory\n\t */\n\tprototype: T;\n}\n\nexport interface Compose {\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initalization function\n\t * @param base The base Class, Factory or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and any creation options\n\t */\n\t<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\t<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initialization function\n\t * @param base The base Class, Facotry or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and nay creation options\n\t */\n\tcreate<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\tcreate<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n}\n\nfunction create<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\nfunction create<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\nfunction create<O>(base: any, initFunction?: ComposeInitializationFunction<any, O>): any {\n\tconst factory = cloneFactory();\n\tif (initFunction) {\n\t\tinitFnMap.get(factory).push(initFunction);\n\t}\n\n\t/* mixin the base into the prototype */\n\tcopyProperties(factory.prototype, typeof base === 'function' ? base.prototype : base);\n\n\t/* return the new constructor */\n\treturn factory;\n\t}\n\n/* Extend factory with static properties */\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Add static properties to a factory\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<S>(staticProperties: S): this & S;\n}\n\nexport interface Compose {\n\t/**\n\t * Add static properties to a factory\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<F extends ComposeFactory<T, O>, T, O, S>(factory: F, staticProperties: S): F & S;\n}\n\nfunction _static<F extends ComposeFactory<T, O>, T, O, S>(factory: F, staticProperties: S): F & S {\n\treturn <F & S> cloneFactory(factory, staticProperties);\n}\n\n/**\n * A factory construction utility\n * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n * @param initFunction An optional initialization function for the factory\n */\nconst compose = create as Compose;\n\n/* Add static methods to compose */\ncompose.create = create;\ncompose.static = _static;\ncompose.extend = extend;\ncompose.mixin = mixin;\ncompose.overlay = overlay;\ncompose.from = from;\ncompose.before = before;\ncompose.after = after;\ncompose.around = around;\ncompose.aspect = aspect;\n\nexport default compose;\n"]}