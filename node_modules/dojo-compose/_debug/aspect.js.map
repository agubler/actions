{"version":3,"file":"aspect.js","sourceRoot":"","sources":["aspect.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\n\nexport interface AdvisingFunction extends Function {\n\t/**\n\t * The next advice in an advice chain\n\t */\n\tnext: AdvisingFunction;\n\n\t/**\n\t * The previous advice in an advice chain\n\t */\n\tprevious: AdvisingFunction;\n}\n\nexport interface DispatchAdvice<T> {\n\tbefore?: BeforeAdvice[];\n\tafter?: AfterAdvice<T>[];\n\tjoinPoint: Function;\n}\n\nexport interface BeforeAdvice {\n\t/**\n\t * Advice which is applied *before*, receiving the original arguments, if the advising function returns\n\t * a value, it is passed further along taking the place of the original arguments.\n\t * @param args The arguments the method was called with\n\t */\n\t(...args: any[]): any[] | void;\n}\n\nexport interface AfterAdvice<T> {\n\t/**\n\t * Advice which is applied *after*, receiving the result and arguments from the join point.\n\t *\n\t * @param result The result from the function being advised\n\t * @param args The arguments that were supplied to the advised function\n\t * @returns The value returned from the advice is then the result of calling the method\n\t */\n\t(result: T, ...args: any[]): T;\n}\n\nexport interface AroundAdvice<T> {\n\t/**\n\t * Advice which is applied *around*.  The advising function receives the original function and needs to\n\t * return a new function which will then invoke the original function.\n\t *\n\t * @param origFn The original function\n\t * @returns A new function which will inoke the original function.\n\t */\n\t(origFn: GenericFunction<T>): (...args: any[]) => T;\n}\n\n/**\n * Types of advice\n */\nexport enum AdviceType { Before, After, Around };\n\n/**\n * A weak map of dispatchers used to apply the advice\n */\nconst dispatchAdviceMap = new WeakMap<Function, DispatchAdvice<any>>();\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n * @param joinPoint The function that is to be advised\n */\nfunction getDispatcher<F extends GenericFunction<T>, T>(joinPoint: F): F {\n\n\tfunction dispatcher(...args: any[]): T {\n\t\tconst adviceMap = dispatchAdviceMap.get(dispatcher);\n\t\tif (adviceMap.before) {\n\t\t\targs = adviceMap.before.reduce((previousArgs, advice) => {\n\t\t\t\tconst currentArgs = advice.apply(this, previousArgs);\n\t\t\t\treturn currentArgs ? currentArgs : previousArgs;\n\t\t\t}, args);\n\t\t}\n\t\tlet result = adviceMap.joinPoint.apply(this, args);\n\t\tif (adviceMap.after) {\n\t\t\tresult = adviceMap.after.reduce((previousResult, advice) => {\n\t\t\t\treturn advice.apply(this, [ previousResult ].concat(args));\n\t\t\t}, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tdispatchAdviceMap.set(dispatcher, {\n\t\tjoinPoint: joinPoint\n\t});\n\n\treturn dispatcher as F;\n}\n\n/**\n * Advise a join point (function) with supplied advice\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction advise<F extends GenericFunction<T>, T>(joinPoint: F, type: AdviceType, advice: BeforeAdvice | AfterAdvice<T> | AroundAdvice<T>): F {\n\tlet dispatcher = joinPoint;\n\tif (type === AdviceType.Around) {\n\t\tdispatcher = getDispatcher(advice.apply(this, [ joinPoint ]));\n\t}\n\telse {\n\t\tif (!dispatchAdviceMap.has(joinPoint)) {\n\t\t\tdispatcher = getDispatcher(joinPoint);\n\t\t}\n\t\tconst adviceMap = dispatchAdviceMap.get(dispatcher);\n\t\tif (type === AdviceType.Before) {\n\t\t\t(adviceMap.before || (adviceMap.before = [])).unshift(<BeforeAdvice> advice);\n\t\t}\n\t\telse {\n\t\t\t(adviceMap.after || (adviceMap.after = [])).push(<AfterAdvice<T>> advice);\n\t\t}\n\t}\n\treturn dispatcher;\n}\n\n/**\n * Apply advice *before* the supplied joinPoint (function)\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport function before<F extends GenericFunction<any>>(joinPoint: F, advice: BeforeAdvice): F {\n\treturn advise(joinPoint, AdviceType.Before, advice);\n}\n\n/**\n * Apply advice *after* the supplied joinPoint (function)\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nexport function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: AfterAdvice<T>): F {\n\treturn advise(joinPoint, AdviceType.After, advice);\n}\n\n/**\n * Apply advice *around* the supplied joinPoint (function)\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: AroundAdvice<T>): F {\n\treturn advise<F, T>(joinPoint, AdviceType.Around, advice);\n}\n"]}